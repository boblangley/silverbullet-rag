"""
title: Silverbullet RAG Pipe
author: silverbullet-rag
author_url: https://github.com/silverbullet-rag/silverbullet-rag
version: 0.4.0
description: RAG pipe that queries a Silverbullet knowledge graph via gRPC with folder context support
license: MIT
"""

import json
from typing import Any, Dict, Generator, Iterator, List, Optional, Union

import grpc
from pydantic import BaseModel, Field

# =============================================================================
# Embedded protobuf stubs (generated from proto/rag.proto)
# =============================================================================

# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: proto/rag.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder

_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC, 6, 31, 1, "", "proto/rag.proto"
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(
    b'\n\x0fproto/rag.proto\x12\x10silverbullet_rag"$\n\x0cQueryRequest\x12\x14\n\x0c\x63ypher_query\x18\x01 \x01(\t"E\n\rQueryResponse\x12\x14\n\x0cresults_json\x18\x01 \x01(\t\x12\x0f\n\x07success\x18\x02 \x01(\x08\x12\r\n\x05\x65rror\x18\x03 \x01(\t"/\n\rSearchRequest\x12\x0f\n\x07keyword\x18\x01 \x01(\t\x12\r\n\x05limit\x18\x02 \x01(\x05"F\n\x0eSearchResponse\x12\x14\n\x0cresults_json\x18\x01 \x01(\t\x12\x0f\n\x07success\x18\x02 \x01(\x08\x12\r\n\x05\x65rror\x18\x03 \x01(\t"`\n\x15SemanticSearchRequest\x12\r\n\x05query\x18\x01 \x01(\t\x12\r\n\x05limit\x18\x02 \x01(\x05\x12\x13\n\x0b\x66ilter_tags\x18\x03 \x03(\t\x12\x14\n\x0c\x66ilter_pages\x18\x04 \x03(\t"N\n\x16SemanticSearchResponse\x12\x14\n\x0cresults_json\x18\x01 \x01(\t\x12\x0f\n\x07success\x18\x02 \x01(\x08\x12\r\n\x05\x65rror\x18\x03 \x01(\t"\xa6\x01\n\x13HybridSearchRequest\x12\r\n\x05query\x18\x01 \x01(\t\x12\r\n\x05limit\x18\x02 \x01(\x05\x12\x13\n\x0b\x66ilter_tags\x18\x03 \x03(\t\x12\x14\n\x0c\x66ilter_pages\x18\x04 \x03(\t\x12\x15\n\rfusion_method\x18\x05 \x01(\t\x12\x17\n\x0fsemantic_weight\x18\x06 \x01(\x02\x12\x16\n\x0ekeyword_weight\x18\x07 \x01(\x02"L\n\x14HybridSearchResponse\x12\x14\n\x0cresults_json\x18\x01 \x01(\t\x12\x0f\n\x07success\x18\x02 \x01(\x08\x12\r\n\x05\x65rror\x18\x03 \x01(\t"$\n\x0fReadPageRequest\x12\x11\n\tpage_name\x18\x01 \x01(\t"C\n\x10ReadPageResponse\x12\x0f\n\x07success\x18\x01 \x01(\x08\x12\r\n\x05\x65rror\x18\x02 \x01(\t\x12\x0f\n\x07\x63ontent\x18\x03 \x01(\t"`\n\x14ProposeChangeRequest\x12\x13\n\x0btarget_page\x18\x01 \x01(\t\x12\x0f\n\x07\x63ontent\x18\x02 \x01(\t\x12\r\n\x05title\x18\x03 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t"t\n\x15ProposeChangeResponse\x12\x0f\n\x07success\x18\x01 \x01(\x08\x12\r\n\x05\x65rror\x18\x02 \x01(\t\x12\x15\n\rproposal_path\x18\x03 \x01(\t\x12\x13\n\x0bis_new_page\x18\x04 \x01(\x08\x12\x0f\n\x07message\x18\x05 \x01(\t"&\n\x14ListProposalsRequest\x12\x0e\n\x06status\x18\x01 \x01(\t"\xa3\x01\n\x0cProposalInfo\x12\x0c\n\x04path\x18\x01 \x01(\t\x12\x13\n\x0btarget_page\x18\x02 \x01(\t\x12\r\n\x05title\x18\x03 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x04 \x01(\t\x12\x0e\n\x06status\x18\x05 \x01(\t\x12\x13\n\x0bis_new_page\x18\x06 \x01(\x08\x12\x13\n\x0bproposed_by\x18\x07 \x01(\t\x12\x12\n\ncreated_at\x18\x08 \x01(\t"y\n\x15ListProposalsResponse\x12\x0f\n\x07success\x18\x01 \x01(\x08\x12\r\n\x05\x65rror\x18\x02 \x01(\t\x12\r\n\x05\x63ount\x18\x03 \x01(\x05\x12\x31\n\tproposals\x18\x04 \x03(\x0b\x32\x1e.silverbullet_rag.ProposalInfo"0\n\x17WithdrawProposalRequest\x12\x15\n\rproposal_path\x18\x01 \x01(\t"K\n\x18WithdrawProposalResponse\x12\x0f\n\x07success\x18\x01 \x01(\x08\x12\r\n\x05\x65rror\x18\x02 \x01(\t\x12\x0f\n\x07message\x18\x03 \x01(\t".\n\x17GetFolderContextRequest\x12\x13\n\x0b\x66older_path\x18\x01 \x01(\t"\x88\x01\n\x18GetFolderContextResponse\x12\x0f\n\x07success\x18\x01 \x01(\x08\x12\r\n\x05\x65rror\x18\x02 \x01(\t\x12\r\n\x05\x66ound\x18\x03 \x01(\x08\x12\x11\n\tpage_name\x18\x04 \x01(\t\x12\x14\n\x0cpage_content\x18\x05 \x01(\t\x12\x14\n\x0c\x66older_scope\x18\x06 \x01(\t2\xd4\x06\n\nRAGService\x12H\n\x05Query\x12\x1e.silverbullet_rag.QueryRequest\x1a\x1f.silverbullet_rag.QueryResponse\x12K\n\x06Search\x12\x1f.silverbullet_rag.SearchRequest\x1a .silverbullet_rag.SearchResponse\x12\x63\n\x0eSemanticSearch\x12\'.silverbullet_rag.SemanticSearchRequest\x1a(.silverbullet_rag.SemanticSearchResponse\x12]\n\x0cHybridSearch\x12%.silverbullet_rag.HybridSearchRequest\x1a&.silverbullet_rag.HybridSearchResponse\x12Q\n\x08ReadPage\x12!.silverbullet_rag.ReadPageRequest\x1a".silverbullet_rag.ReadPageResponse\x12`\n\rProposeChange\x12&.silverbullet_rag.ProposeChangeRequest\x1a\'.silverbullet_rag.ProposeChangeResponse\x12`\n\rListProposals\x12&.silverbullet_rag.ListProposalsRequest\x1a\'.silverbullet_rag.ListProposalsResponse\x12i\n\x10WithdrawProposal\x12).silverbullet_rag.WithdrawProposalRequest\x1a*.silverbullet_rag.WithdrawProposalResponse\x12i\n\x10GetFolderContext\x12).silverbullet_rag.GetFolderContextRequest\x1a*.silverbullet_rag.GetFolderContextResponseb\x06proto3'
)

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, "proto.rag_pb2", _globals)
if not _descriptor._USE_C_DESCRIPTORS:
    DESCRIPTOR._loaded_options = None
    _globals["_QUERYREQUEST"]._serialized_start = 37
    _globals["_QUERYREQUEST"]._serialized_end = 73
    _globals["_QUERYRESPONSE"]._serialized_start = 75
    _globals["_QUERYRESPONSE"]._serialized_end = 144
    _globals["_SEARCHREQUEST"]._serialized_start = 146
    _globals["_SEARCHREQUEST"]._serialized_end = 193
    _globals["_SEARCHRESPONSE"]._serialized_start = 195
    _globals["_SEARCHRESPONSE"]._serialized_end = 265
    _globals["_SEMANTICSEARCHREQUEST"]._serialized_start = 267
    _globals["_SEMANTICSEARCHREQUEST"]._serialized_end = 363
    _globals["_SEMANTICSEARCHRESPONSE"]._serialized_start = 365
    _globals["_SEMANTICSEARCHRESPONSE"]._serialized_end = 443
    _globals["_HYBRIDSEARCHREQUEST"]._serialized_start = 446
    _globals["_HYBRIDSEARCHREQUEST"]._serialized_end = 612
    _globals["_HYBRIDSEARCHRESPONSE"]._serialized_start = 614
    _globals["_HYBRIDSEARCHRESPONSE"]._serialized_end = 690
    _globals["_READPAGEREQUEST"]._serialized_start = 692
    _globals["_READPAGEREQUEST"]._serialized_end = 728
    _globals["_READPAGERESPONSE"]._serialized_start = 730
    _globals["_READPAGERESPONSE"]._serialized_end = 797
    _globals["_PROPOSECHANGEREQUEST"]._serialized_start = 799
    _globals["_PROPOSECHANGEREQUEST"]._serialized_end = 895
    _globals["_PROPOSECHANGERESPONSE"]._serialized_start = 897
    _globals["_PROPOSECHANGERESPONSE"]._serialized_end = 1013
    _globals["_LISTPROPOSALSREQUEST"]._serialized_start = 1015
    _globals["_LISTPROPOSALSREQUEST"]._serialized_end = 1053
    _globals["_PROPOSALINFO"]._serialized_start = 1056
    _globals["_PROPOSALINFO"]._serialized_end = 1219
    _globals["_LISTPROPOSALSRESPONSE"]._serialized_start = 1221
    _globals["_LISTPROPOSALSRESPONSE"]._serialized_end = 1342
    _globals["_WITHDRAWPROPOSALREQUEST"]._serialized_start = 1344
    _globals["_WITHDRAWPROPOSALREQUEST"]._serialized_end = 1392
    _globals["_WITHDRAWPROPOSALRESPONSE"]._serialized_start = 1394
    _globals["_WITHDRAWPROPOSALRESPONSE"]._serialized_end = 1469
    _globals["_GETFOLDERCONTEXTREQUEST"]._serialized_start = 1471
    _globals["_GETFOLDERCONTEXTREQUEST"]._serialized_end = 1517
    _globals["_GETFOLDERCONTEXTRESPONSE"]._serialized_start = 1520
    _globals["_GETFOLDERCONTEXTRESPONSE"]._serialized_end = 1656
    _globals["_RAGSERVICE"]._serialized_start = 1659
    _globals["_RAGSERVICE"]._serialized_end = 2511
# @@protoc_insertion_point(module_scope)


# gRPC Stub
class RAGServiceStub(object):
    """RAG service for fast hooks integration"""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Query = channel.unary_unary(
            "/silverbullet_rag.RAGService/Query",
            request_serializer=QueryRequest.SerializeToString,
            response_deserializer=QueryResponse.FromString,
            _registered_method=True,
        )
        self.Search = channel.unary_unary(
            "/silverbullet_rag.RAGService/Search",
            request_serializer=SearchRequest.SerializeToString,
            response_deserializer=SearchResponse.FromString,
            _registered_method=True,
        )
        self.SemanticSearch = channel.unary_unary(
            "/silverbullet_rag.RAGService/SemanticSearch",
            request_serializer=SemanticSearchRequest.SerializeToString,
            response_deserializer=SemanticSearchResponse.FromString,
            _registered_method=True,
        )
        self.HybridSearch = channel.unary_unary(
            "/silverbullet_rag.RAGService/HybridSearch",
            request_serializer=HybridSearchRequest.SerializeToString,
            response_deserializer=HybridSearchResponse.FromString,
            _registered_method=True,
        )
        self.ReadPage = channel.unary_unary(
            "/silverbullet_rag.RAGService/ReadPage",
            request_serializer=ReadPageRequest.SerializeToString,
            response_deserializer=ReadPageResponse.FromString,
            _registered_method=True,
        )
        self.ProposeChange = channel.unary_unary(
            "/silverbullet_rag.RAGService/ProposeChange",
            request_serializer=ProposeChangeRequest.SerializeToString,
            response_deserializer=ProposeChangeResponse.FromString,
            _registered_method=True,
        )
        self.ListProposals = channel.unary_unary(
            "/silverbullet_rag.RAGService/ListProposals",
            request_serializer=ListProposalsRequest.SerializeToString,
            response_deserializer=ListProposalsResponse.FromString,
            _registered_method=True,
        )
        self.WithdrawProposal = channel.unary_unary(
            "/silverbullet_rag.RAGService/WithdrawProposal",
            request_serializer=WithdrawProposalRequest.SerializeToString,
            response_deserializer=WithdrawProposalResponse.FromString,
            _registered_method=True,
        )
        self.GetFolderContext = channel.unary_unary(
            "/silverbullet_rag.RAGService/GetFolderContext",
            request_serializer=GetFolderContextRequest.SerializeToString,
            response_deserializer=GetFolderContextResponse.FromString,
            _registered_method=True,
        )


# =============================================================================
# Open WebUI Pipe
# =============================================================================


class Pipe:
    """Open WebUI Pipe for Silverbullet RAG via gRPC.

    Features:
    - Folder context injection: Maps Open WebUI folders to Silverbullet pages
      via 'openwebui-folder' frontmatter property
    - Hybrid search: Combines keyword and semantic search per message
    - Search scoping: When folder context is found, searches are scoped to
      the corresponding Silverbullet folder
    """

    class Valves(BaseModel):
        """Configuration valves for the pipe (admin settings)."""

        GRPC_HOST: str = Field(
            default="localhost:50051", description="gRPC server address (host:port)"
        )
        MAX_RESULTS: int = Field(
            default=5, description="Maximum search results to return"
        )
        SEARCH_TYPE: str = Field(
            default="hybrid",
            description="Search type: 'hybrid', 'semantic', or 'keyword'",
        )
        ENABLE_FOLDER_CONTEXT: bool = Field(
            default=True,
            description="Enable folder-to-page mapping via openwebui-folder frontmatter",
        )

    class UserValves(BaseModel):
        """Per-user configurable settings."""

        # Scope customization
        include_paths: str = Field(
            default="",
            description="Additional folder paths to always include in results (comma-separated, e.g., 'Reference,Shared/Templates')",
        )
        include_tags: str = Field(
            default="",
            description="Tags to always include in results regardless of scope (comma-separated, e.g., 'reference,glossary')",
        )
        scope_mode: str = Field(
            default="prefer",
            description="How to handle folder scoping: 'strict' (only scoped), 'prefer' (scoped first, then global), 'none' (no scoping)",
        )

        # Context budget
        max_context_chars: int = Field(
            default=8000,
            description="Maximum total characters for injected context (0 = unlimited)",
        )
        project_context_chars: int = Field(
            default=4000,
            description="Maximum characters for project/folder context (0 = full page)",
        )
        truncate_results: bool = Field(
            default=True,
            description="Truncate individual search results to fit within budget",
        )

    def __init__(self):
        self.type = "filter"
        self.name = "Silverbullet RAG"
        self.valves = self.Valves()
        self.user_valves = self.UserValves()
        self._channel = None
        self._stub = None
        # Cache folder context per chat to avoid repeated lookups
        self._folder_context_cache: Dict[str, Dict[str, Any]] = {}

    def _ensure_connected(self):
        """Lazy initialization of gRPC connection."""
        if self._channel is None:
            self._channel = grpc.insecure_channel(self.valves.GRPC_HOST)
            self._stub = RAGServiceStub(self._channel)

    def pipes(self) -> List[dict]:
        """Return list of available pipes."""
        return [{"id": "silverbullet_rag", "name": "Silverbullet RAG"}]

    def _get_folder_path(self, body: dict) -> Optional[str]:
        """Extract folder path from Open WebUI request body.

        Open WebUI passes chat metadata including folder information.
        This extracts the folder path if available.

        Args:
            body: Request body from Open WebUI

        Returns:
            Folder path string or None if not in a folder
        """
        # Check for __metadata__ which contains chat info
        metadata = body.get("__metadata__", {})

        # Try to get folder from chat metadata
        chat_info = metadata.get("chat", {})
        folder_id = chat_info.get("folder_id")

        if folder_id:
            # If we have folder hierarchy, construct the path
            folders = metadata.get("folders", {})
            if folders:
                return self._build_folder_path(folder_id, folders)
            return folder_id

        return None

    def _build_folder_path(self, folder_id: str, folders: dict) -> str:
        """Build folder path from folder hierarchy.

        Args:
            folder_id: Current folder ID
            folders: Dictionary of folder info by ID

        Returns:
            Full folder path like "Projects/MyProject"
        """
        path_parts = []
        current_id = folder_id

        while current_id and current_id in folders:
            folder_info = folders[current_id]
            path_parts.insert(0, folder_info.get("name", current_id))
            current_id = folder_info.get("parent_id")

        return "/".join(path_parts) if path_parts else folder_id

    def _get_folder_context(self, folder_path: str) -> Optional[Dict[str, Any]]:
        """Fetch folder context from the gRPC server.

        Args:
            folder_path: Open WebUI folder path

        Returns:
            Dict with page_name, page_content, folder_scope if found, else None
        """
        try:
            response = self._stub.GetFolderContext(
                GetFolderContextRequest(folder_path=folder_path)
            )

            if response.success and response.found:
                return {
                    "page_name": response.page_name,
                    "page_content": response.page_content,
                    "folder_scope": response.folder_scope,
                }
        except grpc.RpcError as e:
            print(f"GetFolderContext error: {e.code()}: {e.details()}")
        except Exception as e:
            print(f"GetFolderContext error: {e}")

        return None

    def _get_user_valves(self, __user__: Optional[dict]) -> "Pipe.UserValves":
        """Get user valves, merging with defaults.

        Args:
            __user__: User dict from Open WebUI (contains 'valves' key)

        Returns:
            UserValves instance with user overrides applied
        """
        if __user__ and "valves" in __user__:
            try:
                return self.UserValves(**__user__["valves"])
            except Exception:
                pass
        return self.user_valves

    def _parse_comma_list(self, value: str) -> List[str]:
        """Parse comma-separated string into list of trimmed values.

        Args:
            value: Comma-separated string

        Returns:
            List of trimmed, non-empty strings
        """
        if not value:
            return []
        return [v.strip() for v in value.split(",") if v.strip()]

    def _truncate_text(self, text: str, max_chars: int) -> str:
        """Truncate text to max characters, ending at word boundary.

        Args:
            text: Text to truncate
            max_chars: Maximum characters (0 = no limit)

        Returns:
            Truncated text with ellipsis if needed
        """
        if max_chars <= 0 or len(text) <= max_chars:
            return text

        # Find last space before limit
        truncated = text[:max_chars]
        last_space = truncated.rfind(" ")
        if last_space > max_chars * 0.7:  # Only use space if reasonably close
            truncated = truncated[:last_space]

        return truncated.rstrip() + "..."

    def pipe(
        self,
        user_message: str,
        model_id: str,
        messages: List[dict],
        body: dict,
        __user__: Optional[dict] = None,
    ) -> Union[str, Generator, Iterator]:
        """Process messages and inject RAG context.

        This method:
        1. Checks for folder context (maps Open WebUI folder to Silverbullet page)
        2. Injects project/folder context if found
        3. Performs hybrid search (scoped to folder if applicable)
        4. Injects search results as additional context
        5. Applies context budget limits

        Args:
            user_message: The latest user message
            model_id: Selected model ID
            messages: Full conversation history
            body: Request body
            __user__: User info including user valves

        Returns:
            Modified messages with RAG context injected
        """
        self._ensure_connected()

        if not user_message or len(user_message.strip()) < 3:
            return body

        # Get user-specific settings
        uv = self._get_user_valves(__user__)

        # Get chat ID for caching folder context
        chat_id = body.get("__metadata__", {}).get("chat", {}).get("id", "default")
        folder_scope = None
        folder_context = None

        try:
            # Check for folder context (only on first lookup per chat)
            if self.valves.ENABLE_FOLDER_CONTEXT:
                if chat_id not in self._folder_context_cache:
                    folder_path = self._get_folder_path(body)
                    if folder_path:
                        folder_context = self._get_folder_context(folder_path)
                        self._folder_context_cache[chat_id] = folder_context or {
                            "_checked": True
                        }
                    else:
                        self._folder_context_cache[chat_id] = {"_checked": True}
                else:
                    cached = self._folder_context_cache[chat_id]
                    if cached and not cached.get("_checked"):
                        folder_context = cached

                if folder_context:
                    folder_scope = folder_context.get("folder_scope")

            # Parse user include paths and tags
            include_paths = self._parse_comma_list(uv.include_paths)
            include_tags = self._parse_comma_list(uv.include_tags)

            # Perform search with scope mode handling
            search_results = self._perform_search(
                query=user_message,
                scope=folder_scope,
                scope_mode=uv.scope_mode,
                include_paths=include_paths,
                include_tags=include_tags,
            )

            # Track context budget
            total_budget = uv.max_context_chars
            remaining_budget = total_budget if total_budget > 0 else float("inf")

            # Build combined context
            context_parts = []

            # Add folder/project context if this is a new chat with folder context
            if folder_context and folder_context.get("page_content"):
                page_name = folder_context.get("page_name", "Project")
                page_content = folder_context.get("page_content", "")

                # Apply project context budget
                if uv.project_context_chars > 0:
                    page_content = self._truncate_text(
                        page_content, uv.project_context_chars
                    )

                project_context = f"# Project Context: {page_name}\n\n{page_content}"

                # Check against total budget
                if (
                    remaining_budget == float("inf")
                    or len(project_context) <= remaining_budget
                ):
                    context_parts.append(project_context)
                    if remaining_budget != float("inf"):
                        remaining_budget -= len(project_context)

            # Add search results context within remaining budget
            if search_results and remaining_budget > 100:  # Need at least some space
                search_context = self._build_context(
                    search_results,
                    max_chars=int(remaining_budget)
                    if remaining_budget != float("inf")
                    else 0,
                    truncate=uv.truncate_results,
                )
                if search_context:
                    context_parts.append(f"# Relevant Knowledge\n\n{search_context}")

            if not context_parts:
                return body

            # Build system message with all context
            full_context = "\n\n---\n\n".join(context_parts)
            system_message = {
                "role": "system",
                "content": f"""You have access to the user's Silverbullet knowledge base.

{full_context}

Use this information to provide more informed and personalized responses. Reference specific pages or notes when relevant.""",
            }

            # Insert system message before the last user message
            modified_messages = messages[:-1] + [system_message] + [messages[-1]]
            body["messages"] = modified_messages

        except grpc.RpcError as e:
            print(f"gRPC error: {e.code()}: {e.details()}")
        except Exception as e:
            print(f"RAG pipe error: {e}")

        return body

    def _perform_search(
        self,
        query: str,
        scope: Optional[str] = None,
        scope_mode: str = "prefer",
        include_paths: Optional[List[str]] = None,
        include_tags: Optional[List[str]] = None,
    ) -> List[Dict[str, Any]]:
        """Perform search with scope mode and include filters.

        Args:
            query: Search query
            scope: Optional folder path to scope results
            scope_mode: How to handle scoping ('strict', 'prefer', 'none')
            include_paths: Additional paths to always include
            include_tags: Tags to always include regardless of scope

        Returns:
            List of search results
        """
        include_paths = include_paths or []
        include_tags = include_tags or []

        try:
            # Request more results if we need to filter/reorder
            fetch_limit = self.valves.MAX_RESULTS
            if scope and scope_mode in ("strict", "prefer"):
                fetch_limit = self.valves.MAX_RESULTS * 3  # Fetch extra for filtering

            if self.valves.SEARCH_TYPE == "hybrid":
                response = self._stub.HybridSearch(
                    HybridSearchRequest(
                        query=query,
                        limit=fetch_limit,
                        filter_tags=list(include_tags) if include_tags else [],
                    )
                )
            elif self.valves.SEARCH_TYPE == "semantic":
                response = self._stub.SemanticSearch(
                    SemanticSearchRequest(
                        query=query,
                        limit=fetch_limit,
                        filter_tags=list(include_tags) if include_tags else [],
                    )
                )
            else:  # keyword
                response = self._stub.Search(
                    SearchRequest(
                        keyword=query,
                        limit=fetch_limit,
                    )
                )

            if not response.success:
                print(f"RAG search error: {response.error}")
                return []

            results = json.loads(response.results_json)
            if not results:
                return []

            # Apply scope mode filtering
            if scope_mode == "none" or not scope:
                # No scoping - return results as-is
                return results[: self.valves.MAX_RESULTS]

            elif scope_mode == "strict":
                # Only scoped results + include_paths
                filtered = []
                for r in results:
                    if self._result_in_scope(r, scope):
                        filtered.append(r)
                    elif self._result_in_include_paths(r, include_paths):
                        filtered.append(r)
                    elif self._result_has_include_tags(r, include_tags):
                        filtered.append(r)
                return filtered[: self.valves.MAX_RESULTS]

            else:  # prefer
                # Scoped results first, then others
                scoped = []
                included = []
                other = []

                for r in results:
                    if self._result_in_scope(r, scope):
                        scoped.append(r)
                    elif self._result_in_include_paths(r, include_paths):
                        included.append(r)
                    elif self._result_has_include_tags(r, include_tags):
                        included.append(r)
                    else:
                        other.append(r)

                # Combine: scoped first, then included, then others
                combined = scoped + included + other
                return combined[: self.valves.MAX_RESULTS]

        except Exception as e:
            print(f"Search error: {e}")

        return []

    def _result_in_scope(self, result: Dict[str, Any], scope: str) -> bool:
        """Check if a search result is within the folder scope.

        Args:
            result: Search result dict
            scope: Folder scope path

        Returns:
            True if result is in scope
        """
        # Results are nested under 'col0' from the search response
        chunk = result.get("col0", result)
        file_path = chunk.get("file_path", "")

        # Normalize paths and check if file is in scope folder
        # e.g., scope="Projects/MyProject", file="/space/Projects/MyProject/notes.md"
        return scope.lower() in file_path.lower()

    def _result_in_include_paths(
        self, result: Dict[str, Any], include_paths: List[str]
    ) -> bool:
        """Check if a search result is in one of the include paths.

        Args:
            result: Search result dict
            include_paths: List of folder paths to include

        Returns:
            True if result is in any include path
        """
        if not include_paths:
            return False

        chunk = result.get("col0", result)
        file_path = chunk.get("file_path", "").lower()

        for path in include_paths:
            if path.lower() in file_path:
                return True
        return False

    def _result_has_include_tags(
        self, result: Dict[str, Any], include_tags: List[str]
    ) -> bool:
        """Check if a search result has any of the include tags.

        Args:
            result: Search result dict
            include_tags: List of tags to include

        Returns:
            True if result has any include tag
        """
        if not include_tags:
            return False

        chunk = result.get("col0", result)
        result_tags = chunk.get("tags", [])
        if isinstance(result_tags, str):
            result_tags = [result_tags]

        result_tags_lower = [t.lower() for t in result_tags]
        for tag in include_tags:
            if tag.lower() in result_tags_lower:
                return True
        return False

    def _build_context(
        self,
        results: List[dict],
        max_chars: int = 0,
        truncate: bool = True,
    ) -> str:
        """Build context text from search results with budget limits.

        Args:
            results: List of search result dictionaries
            max_chars: Maximum characters for context (0 = unlimited)
            truncate: Whether to truncate individual results to fit

        Returns:
            Formatted context string
        """
        if not results:
            return ""

        context_parts = []
        seen_sources = set()
        total_chars = 0

        for result in results[: self.valves.MAX_RESULTS]:
            # Results are nested under 'col0' from the search response
            chunk = result.get("col0", result)

            content = chunk.get("content", "")
            header = chunk.get("header", "Unknown")
            file_path = chunk.get("file_path", chunk.get("page", ""))

            # Skip if no content
            if not content:
                continue

            source = f"{file_path}#{header}"
            if source in seen_sources:
                continue
            seen_sources.add(source)

            # Build the context entry
            entry = f"## {header}\n{content}\n\nSource: {file_path}"

            # Check budget
            if max_chars > 0:
                separator_len = len("\n\n---\n\n") if context_parts else 0
                entry_len = len(entry) + separator_len

                if total_chars + entry_len > max_chars:
                    if truncate and total_chars < max_chars:
                        # Truncate this entry to fit remaining budget
                        remaining = (
                            max_chars - total_chars - separator_len - 50
                        )  # Reserve for header/source
                        if remaining > 100:
                            truncated_content = self._truncate_text(content, remaining)
                            entry = f"## {header}\n{truncated_content}\n\nSource: {file_path}"
                            context_parts.append(entry)
                    break  # Budget exhausted

                total_chars += entry_len

            context_parts.append(entry)

        return "\n\n---\n\n".join(context_parts)
